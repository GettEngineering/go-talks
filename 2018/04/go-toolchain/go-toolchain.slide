Intro to the Go toolchain
Go command and useful tools
18:00 27 Apr 2018
Tags: golang, go, toolchain

Ilya Danilkin
Server Developer, Gett RnD
danilkin@gett.com
https://gett.com/ru/
@nezorflame

* Go toolchain

.background images/background.png

Golang toolchain consists of, [[https://golang.org/cmd][but not limited to]], the next tools:

    api 	    computes the exported API of a set of Go packages
    asm 	    assembles the source file into an object file named for the
                basename of the argument source file with a .o suffix
    cgo         enables the creation of Go packages that call C code
    compile 	compiles a single Go package comprising the files named on the command line
    cover       program for analyzing the coverage profiles generated by 'go test -coverprofile ...'
    doc 	    builds documentation for the package (usually run as 'go doc')
    fix         finds Go programs that use old APIs and rewrites them to use newer ones
    go          tool for managing Go source code
    gofmt       formats Go programs
    link        reads the Go archive or object for a package main with its dependencies
                and combines them into an executable binary
    nm          lists the symbols defined or used by an object file, archive, or executable
    objdump 	disassembles executable files
    pprof       interprets and displays profiles of Go programs
    test2json   converts 'go test' output to a machine-readable JSON stream
    trace       tool for viewing trace files
    vet         examines Go source code and reports suspicious constructs

* go command

From official docs:

    Go is a tool for managing Go source code.

*Command*list*

    build       compile packages and dependencies
    clean       remove object files and cached files
    doc         show documentation for package or symbol
    env         print Go environment information
    bug         start a bug report
    fix         update packages to use new APIs
    fmt         gofmt (reformat) package sources
    generate    generate Go files by processing source
    get         download and install packages and dependencies
    install     compile and install packages and dependencies
    list        list packages
    run         compile and run Go program
    test        test packages
    tool        run specified go tool
    version     print Go version
    vet         report likely mistakes in packages

* go build

.background images/background.png

*Usage*

    go build [-o output] [-i] [build flags] [packages]

*Useful*flags*

    -race       data race detection (supported only for amd64 on linux/freebsd/darwin/windows)
    -ldflags    arguments to pass on each 'go tool link' invocation
    -tags       space-separated list of build tags to consider satisfied during the build
    -compiler   compiler name (gccgo or gc)
    -gcflags    arguments to pass on each 'go tool compile' invocation
    -asmflags   arguments to pass on each 'go tool asm' invocation
    -buildmode  build mode to use
    -toolexec   arguments to invoke toolchain programs, like 'vet' and 'asm'
    -a          force rebuilding of packages that are already up-to-date
    -n          print the commands but do not run them
    -v          print the names of packages as they are compiled
    -x          print the commands
    -work       print the name of the temporary work directory and don't delete it when exiting

* Race detection

.background images/background.png

    A data race occurs when two goroutines access the same variable concurrently
    and at least one of the accesses is a write.

To help diagnose such bugs, Go includes a built-in data race detector. 
To use it, add the *-race* flag to the go command:

    $ go test -race mypkg    // to test the package
    $ go run -race mysrc.go  // to run the source file
    $ go build -race mycmd   // to build the command
    $ go install -race mypkg // to install the package

Take notice of these warnings:

    WARNING: DATA RACE

.image images/race.png 120 450

* Linker flags

The *-X* Go linker option, which you can set with *-ldflags*, sets the value of a string variable in the Go program being linked.

*Example*

.code examples/main.go

Using the -X option:

    $ go run main.go
    Hello, World.
    $ go run -ldflags="-X main.who=Gett" main.go
    Hello, Gett.

* Cross-compilation

The *go*tool* wonâ€™t require any bootstrapping if *cgo* is not required.
That allows you to target the following program to any *GOOS/GOARCH* without requiring you to do any additional work. Just invoke *go*build*.

*Example*

.code examples/main.go

E.g. in order to target *Windows*x64*, run the following command:

    $ GOOS=windows GOARCH=amd64 go build main.go
    $ ls
    main.exe main.go

* go install and go run

.background images/background.png

    go install [-i] [build flags] [packages]

Install compiles and installs the packages named by the import paths.
The *-i* flag installs the dependencies of the named packages as well.
Essentially, *go*install*=*go*build*&*mv*mypkg*$GOPATH/bin/.*

    go run [build flags] [-exec xprog] gofiles... [arguments...]

Run compiles and runs the main package comprising the named Go source files.
A Go source file is defined to be a file ending in a literal ".go" suffix.

.image images/gopherswrench.jpg _ 400

* go get

.background images/background.png

*Usage*

    go get [-d] [-f] [-fix] [-insecure] [-t] [-u] [-v] [build flags] [packages]

Get downloads the packages named by the import paths with their dependencies. 
It then installs the named packages, like *go*install*.

*Flags*

    -u          use the network to update the named packages and their dependencies
    -t          download the packages required to build the tests for the specified packages
    -d          stop after downloading the packages (not to install them)
    -f          forces 'get -u' not to verify that each package has been checked out 
                from the source control repository implied by its import path
    -fix        run the fix tool on the downloaded packages 
                before resolving dependencies or building the code
    -insecure   permits fetching from repositories and resolving custom domains 
                using insecure schemes such as HTTP (use with caution)
    -v          enables verbose progress and debug output

* go test

.background images/background.png

*Usage*

    go test [build/test flags] [packages] [build/test flags & test binary flags]

*go*test* automates testing the packages named by the import paths.
It prints a summary of the test results followed by detailed output for each failed package.

*go*test* recompiles each package along with any files with names matching the file pattern **_test.go*.
These additional files can contain test, benchmark and example functions.

Test flags are described [[https://golang.org/cmd/go/#hdr-Testing_flags][here]].

* Examples

.code examples/test.go

* go generate

.background images/background.png

*Usage*

    go generate [-run regexp] [-n] [-v] [-x] [build flags] [file.go... | packages]

*go*generate* runs commands described by directives within existing files. 
Those commands can run any process but the intent is to create or update Go source files.

It is never run automatically by *go*build*, *go*get*, *go*test* and so on. It must be run explicitly.
It scans the file for directives, which are lines of the form:

    //go:generate command argument...

More info on it can be found [[https://blog.golang.org/generate][here]].

* go clean

*Usage*

    go clean [-i] [-r] [-n] [-x] [-cache] [-testcache] [build flags] [packages]

Clean removes object files from package source directories.

To remove a go program:

    $ go clean -i mypkg
    $ rm -r $GOPATH/src/mypkg

*Flags*

    -i          remove the corresponding installed archive or binary (what 'go install' would create)
    -n          print the remove commands it would execute, but not run them
    -r          apply recursively to all the dependencies of the packages named by the import paths
    -x          print remove commands as it executes them
    -cache      remove the entire 'go build' cache
    -testcache  expire all test results in the 'go build' cache

* go fmt and go vet

.background images/background.png

    go fmt [-n] [-x] [packages]

Fmt runs the command *gofmt*-l*-w* on the packages named by the import paths.
It prints the names of the files that are modified.

    go vet [-n] [-x] [build flags] [vet flags] [packages]

Vet runs the *go*tool*vet* command on the packages named by the import paths.

More on *vet* and available checks can be found [[https://golang.org/cmd/vet/][here]]

.image images/jumping.gif

* goimports

In addition to fixing imports, *goimports* also formats your code in the same style as *gofmt* so it can be used as a replacement for your editor's gofmt-on-save hook.

*Download*

    go get -u golang.org/x/tools/cmd/goimports

*Usage*

    goimports [flags] [path ...]

*Flags*

    -d      display diffs instead of rewriting files
    -e      report all errors (not just the first 10 on different lines)
    -l      list files whose formatting differs from goimport's
    -local  put imports beginning with this string after 3rd-party packages; comma-separated list
    -srcdir choose imports as if source code is from dir
    -v      verbose logging
    -w      write result to (source) file instead of stdout

* golint

*golint*!=*gofmt*. *gofmt* reformats Go source code, whereas *golint* prints out style mistakes.
*golint*!=*govet*. *govet* is concerned with correctness, whereas *golint* is concerned with coding style.

*Download*

    go get -u golang.org/x/lint/golint

*Usage*

    golint [flags] # runs on package in current directory
    golint [flags] [packages]
    golint [flags] [directories] # where a '/...' suffix includes all sub-directories
    golint [flags] [files] # all must belong to a single package

*Flags*

    -min_confidence   minimum confidence of a problem to print it (default 0.8)
    -set_exit_status  set exit status to 1 if any issues are found

* gometalinter

.background images/background.png

This is a tool that concurrently runs a whole bunch of those linters and normalises their output to a standard format:

    <file>:<line>:[<column>]: <message> (<linter>)

*Download*

    go get -u gopkg.in/alecthomas/gometalinter.v2

*Usage*

    $ gometalinter --install
    $ cd examples
    $ gometalinter ./...

* Resources

.background images/background.png

- Go docs: [[https://golang.org/cmd/][Commands]]
- Go wiki: [[https://github.com/golang/go/wiki#using-the-go-toolchain][Using the go toolchain]]
- Go blog: [[https://golang.org/doc/articles/race_detector.html][Data Race Detector]]
- Go docs: [[https://golang.org/pkg/testing/][Package testing]]
- Cloudflare blog: [[https://blog.cloudflare.com/setting-go-variables-at-compile-time/][Setting Go variables from the outside]]
- Rakyll's blog: [[https://rakyll.org/cross-compilation/][Go cross compilation]]
- Go docs: [[https://golang.org/cmd/vet/][Command vet]]
- Go docs: [[https://godoc.org/golang.org/x/tools/cmd/goimports][Command goimports]]
- Github: [[https://github.com/golang/lint][Golint]]
- Github: [[https://github.com/alecthomas/gometalinter][Gometalinter]]
